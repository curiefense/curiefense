user  root;
# required for lua code to see env vars from the container
env REDIS_HOST;
env REDIS_PORT;
env REDIS_KEY_PREFIX;
env XFF_TRUSTED_HOPS=1;
# EC2 m1.large comes with 2 cores.
# if we switch to xlarge then
# number of worker_processes shall be 4.
worker_processes auto;
# set open fd limit to X
worker_rlimit_nofile 100000;
events {
    worker_connections  100000;
    use epoll;
}
http {
    
    server {
        resolver local=on;
        access_log /var/log/nginx.metrics.json.log aggregationlog;
        error_log  /var/log/nginx.error.log  error;

        listen 8999;

        set $aggregated '{}';
        set $request_map '{}';

        server_name metrics.curiefense.io;
        location / {
            access_by_lua_block {
                local curiefense  = require "curiefense"
                local agg = curiefense.aggregated_values()
                ngx.var.aggregated = agg
                ngx.header["content-type"] = "text/json"
                ngx.say(agg)
                ngx.exit(200)
            }
        }
    }
    
    include mime.types;
    default_type  application/octet-stream;
    limit_req_zone  $binary_remote_addr  zone=RATELIMIT_ZONE:45m rate=1000r/s;
    # do not provide nginx server versions
    server_tokens   off;
    # use sendfile()
    sendfile        on;
    tcp_nopush on;
    # speed vs. bandwidth
    tcp_nodelay on;
    # todo decide on path
    client_body_temp_path   /tmp/ngx-temp-body;
    ## Start: Size Limits & Buffer Overflows ##
    # todo - move to server
    # <<
    client_body_buffer_size     4M;
    client_header_buffer_size   32k;
    large_client_header_buffers 16 32k;
    ## END: Size Limits & Buffer Overflows ##
    server_names_hash_max_size 512000;
    server_names_hash_bucket_size 128;
    # >>
    # ADDED by Tzury at 30/07/2013
    proxy_headers_hash_max_size 128;
    proxy_headers_hash_bucket_size  1024;
    # ADDED by Tzury at 16/12/2013
    proxy_buffer_size   128k;
    proxy_buffers   4 256k;
    proxy_busy_buffers_size   256k;
    variables_hash_bucket_size 128;
    # Enable Gzip compressed.
    gzip on;
    # Enable compression both for HTTP/1.0 and HTTP/1.1 (required for CloudFront).
    gzip_http_version  1.0;
    # Compression level (1-9).
    # 5 is a perfect compromise between size and cpu usage, offering about
    # 75% reduction for most ascii files (almost identical to level 9).
    gzip_comp_level    5;
    # Don't compress anything that's already small and unlikely to shrink much
    # if at all (the default is 20 bytes, which is bad as that usually leads to
    # larger files after gzipping).
    gzip_min_length    1500;
    # Compress data even for clients that are connecting to us via proxies,
    # identified by the "Via" header (required for CloudFront).
    gzip_proxied       any;
    # Tell proxies to cache both the gzipped and regular version of a resource
    # whenever the client's Accept-Encoding capabilities header varies;
    # Avoids the issue where a non-gzip capable client (which is extremely rare
    # today) would display gibberish if their proxy gave them the gzipped version.
    gzip_vary          on;
    # Compress all output labeled with one of the following MIME-types.
    gzip_types          application/atom+xml
                        application/ecmascript
                        application/javascript
                        application/json
                        application/rdf+xml
                        application/rss+xml
                        application/soap+xml
                        application/vnd.ms-fontobject
                        application/x-font-ttf
                        application/x-javascript
                        application/x-web-app-manifest+json
                        application/xhtml+xml
                        application/xml
                        application/xml+rss
                        application/xml-dtd
                        application/xop+xml
                        font/opentype
                        image/svg+xml
                        image/x-icon
                        text/css
                        text/csv
                        text/javascript
                        text/plain
                        text/xml;
    proxy_cache_path    /tmp/ngx-cache/current
                        levels=1:2
                        keys_zone=cache-zone-one:10m max_size=4096m
                        inactive=60m
                        use_temp_path=off;
    proxy_cache_min_uses 3;
    proxy_cache_revalidate on;
    proxy_cache_use_stale error timeout updating http_500 http_502 http_503 http_504;
    proxy_temp_path     /tmp/ngx-cache-tmp;
    proxy_cache_key     $scheme$http_host$request_uri;
    proxy_ignore_client_abort on;
    lua_regex_cache_max_entries 51200;
    lua_package_path '/lua/?.lua;;';
    log_format curiefenselog escape=none '$request_map';
    log_format aggregationlog escape=none '$aggregated';
    lua_shared_dict rglobals 250m; # use this for production
    underscores_in_headers on;
    ## FROM 2.14 and on. We do not store cache in local disk!
    proxy_cache_bypass 1;
    proxy_no_cache 1;
    map $http_upgrade $connection_upgrade {
        default '';
        ~*.+ Upgrade;
    }
    include /etc/nginx/conf.d/*.conf;
}
