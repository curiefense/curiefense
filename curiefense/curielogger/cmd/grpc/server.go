package main

import (
	"encoding/json"
	"fmt"
	"github.com/curiefense/curiefense/curielogger/pkg"
	"github.com/curiefense/curiefense/curielogger/pkg/entities"
	als "github.com/envoyproxy/go-control-plane/envoy/service/accesslog/v2"
	"github.com/golang/protobuf/ptypes/duration"
	"github.com/golang/protobuf/ptypes/timestamp"
	"log"
	"time"
)

type grpcServer struct {
	logger *pkg.LogSender
}

func newGrpcSrv(sender *pkg.LogSender) *grpcServer {
	return &grpcServer{logger: sender}
}

func (s grpcServer) StreamAccessLogs(x als.AccessLogService_StreamAccessLogsServer) error {
	for {
		fmt.Println(`hello`)
		msg, err := x.Recv()
		if err != nil {
			log.Printf("[ERROR] Error receiving grpc stream message: %v", err)
			return err
		}
		s.parseLogs(msg)
	}
}

func (s *grpcServer) parseLogs(msg *als.StreamAccessLogsMessage) {
	log.Printf("[DEBUG] ====>[%v]", msg.LogEntries)
	hl := msg.GetHttpLogs()
	http_entries := hl.GetLogEntry()
	for _, entry := range http_entries {

		common := entry.GetCommonProperties()
		// Decode curiefense metadata

		curiefense_meta, got_meta := common.GetMetadata().GetFilterMetadata()["com.reblaze.curiefense"]
		if !got_meta { /* This log line was not generated by curiefense */
			log.Printf("[DEBUG] No curiefense metadata => drop log entry")
			continue
		}

		var curieProxyLog entities.CurieProxyLog

		cfm := curiefense_meta.GetFields()
		if rqinfo_s, ok := cfm["request.info"]; ok {
			curiefense_json_string := rqinfo_s.GetStringValue()
			err := json.Unmarshal([]byte(curiefense_json_string), &curieProxyLog)
			if err != nil {
				log.Printf("[ERROR] Error unmarshalling metadata json string [%v]: %v", curiefense_json_string, err)
				continue
			}
		} else {
			log.Printf("[ERROR] did not find request.info in curiefense medatada")
			continue
		}

		log.Printf("[DEBUG] XXXXXXXX curieproxylog=%v", curieProxyLog)

		// Shortcuts

		req := entry.GetRequest()
		resp := entry.GetResponse()
		respflags := common.GetResponseFlags()
		tls := common.GetTlsProperties()
		lan := []string{}
		for _, san := range tls.GetLocalCertificateProperties().GetSubjectAltName() {
			lan = append(lan, san.String())
		}
		pan := []string{}
		for _, san := range tls.GetPeerCertificateProperties().GetSubjectAltName() {
			pan = append(pan, san.String())
		}

		// Create canonical curiefense log structure

		cflog := entities.CuriefenseLog{
			RequestId:   req.GetRequestId(),
			Timestamp:   TimestampToRFC3339(common.GetStartTime()),
			Scheme:      req.GetScheme(),
			Authority:   req.GetAuthority(),
			Port:        req.GetPort().GetValue(),
			Method:      req.GetRequestMethod().String(),
			Path:        req.GetPath(),
			Blocked:     curieProxyLog.Blocked,
			BlockReason: curieProxyLog.BlockReason,
			Tags:        curieProxyLog.Tags,

			RXTimers: entities.RXTimer{
				FirstUpstreamByte: DurationToFloat(common.GetTimeToFirstUpstreamRxByte()),
				LastUpstreamByte:  DurationToFloat(common.GetTimeToLastUpstreamRxByte()),
				LastByte:          DurationToFloat(common.GetTimeToLastRxByte()),
			},
			TXTimers: entities.TXTimer{
				FirstUpstreamByte:   DurationToFloat(common.GetTimeToFirstUpstreamTxByte()),
				LastUpstreamByte:    DurationToFloat(common.GetTimeToLastUpstreamTxByte()),
				FirstDownstreamByte: DurationToFloat(common.GetTimeToFirstDownstreamTxByte()),
				LastDownstreamByte:  DurationToFloat(common.GetTimeToLastDownstreamTxByte()),
			},
			Downstream: entities.Downstream{
				ConnectionTermination:   respflags.GetDownstreamConnectionTermination(),
				DirectRemoteAddress:     common.GetDownstreamDirectRemoteAddress().GetSocketAddress().GetAddress(),
				DirectRemoteAddressPort: common.GetDownstreamDirectRemoteAddress().GetSocketAddress().GetPortValue(),
				LocalAddress:            common.GetDownstreamLocalAddress().GetSocketAddress().GetAddress(),
				LocalAddressPort:        common.GetDownstreamLocalAddress().GetSocketAddress().GetPortValue(),
				ProtocolError:           respflags.GetDownstreamProtocolError(),
				RemoteAddress:           common.GetDownstreamRemoteAddress().GetSocketAddress().GetAddress(),
				RemoteAddressPort:       common.GetDownstreamRemoteAddress().GetSocketAddress().GetPortValue(),
			},
			Upstream: entities.Upstream{
				Cluster:                common.GetUpstreamCluster(),
				ConnectionFailure:      respflags.GetUpstreamConnectionFailure(),
				ConnectionTermination:  respflags.GetUpstreamConnectionTermination(),
				LocalAddress:           common.GetUpstreamLocalAddress().GetSocketAddress().GetAddress(),
				LocalAddressPort:       common.GetUpstreamLocalAddress().GetSocketAddress().GetPortValue(),
				Overflow:               respflags.GetUpstreamOverflow(),
				RemoteAddress:          common.GetUpstreamRemoteAddress().GetSocketAddress().GetAddress(),
				RemoteAddressPort:      common.GetUpstreamRemoteAddress().GetSocketAddress().GetPortValue(),
				RemoteReset:            respflags.GetUpstreamRemoteReset(),
				RequestTimeout:         respflags.GetUpstreamRequestTimeout(),
				RetryLimitExceeded:     respflags.GetUpstreamRetryLimitExceeded(),
				TransportFailureReason: common.GetUpstreamTransportFailureReason(),
			},
			TLS: entities.TLS{
				LocalCertificate: entities.CertificateData{
					Properties:         tls.GetLocalCertificateProperties().GetSubject(),
					PropertiesAltNames: lan,
				},
				PeerCertificate: entities.CertificateData{
					Properties:         tls.GetPeerCertificateProperties().GetSubject(),
					PropertiesAltNames: pan,
				},
				CipherSuite: tls.GetTlsCipherSuite().String(),
				SessionId:   tls.GetTlsSessionId(),
				SNIHostname: tls.GetTlsSniHostname(),
				Version:     tls.GetTlsVersion().String(),
			},
			Request: entities.Request{
				BodyBytes:    req.GetRequestBodyBytes(),
				HeadersBytes: req.GetRequestHeadersBytes(),
				OriginalPath: req.GetOriginalPath(),
				Headers:      curieProxyLog.Headers,
				Cookies:      curieProxyLog.Cookies,
				Arguments:    curieProxyLog.Arguments,
				Geo:          curieProxyLog.Geo,
				Attributes:   curieProxyLog.Attributes,
			},
			Response: entities.Response{
				BodyBytes:    resp.GetResponseBodyBytes(),
				Code:         int(resp.GetResponseCode().GetValue()),
				CodeDetails:  resp.GetResponseCodeDetails(),
				Headers:      resp.GetResponseHeaders(),
				HeadersBytes: resp.GetResponseHeadersBytes(),
				Trailers:     resp.GetResponseTrailers(),
			},
			Metadata: entities.Metadata{
				DelayInjected:              respflags.GetDelayInjected(),
				FailedLocalHealthCheck:     respflags.GetFailedLocalHealthcheck(),
				FaultInjected:              respflags.GetFaultInjected(),
				InvalidEnvoyRequestHeaders: respflags.GetInvalidEnvoyRequestHeaders(),
				LocalReset:                 respflags.GetLocalReset(),
				NoHealthyUpstream:          respflags.GetNoHealthyUpstream(),
				NoRouteFound:               respflags.GetNoRouteFound(),
				RateLimited:                respflags.GetRateLimited(),
				RateLimitServiceError:      respflags.GetRateLimitServiceError(),
				RouteName:                  common.GetRouteName(),
				SampleRate:                 common.GetSampleRate(),
				StreamIdleTimeout:          respflags.GetStreamIdleTimeout(),
				UnauthorizedDetails:        respflags.GetUnauthorizedDetails().GetReason().String(),
			},
		}

		log.Printf("[DEBUG] ---> [ %v:%v %v:%v ] <---", cflog.Downstream.RemoteAddress, cflog.Downstream.RemoteAddressPort,
			cflog.Downstream.LocalAddress, cflog.Downstream.LocalAddressPort)

		log.Printf("[DEBUG] cflog=%v", cflog)

		s.logger.Write(entities.LogEntry{
			FullEntry:     entry,
			CfLog:         cflog,
			CurieProxyLog: curieProxyLog,
		})
	}
}

func DurationToFloat(d *duration.Duration) float64 {
	if d != nil {
		return float64(d.GetSeconds()) + float64(d.GetNanos())*1e-9
	}
	return 0
}

func TimestampToRFC3339(d *timestamp.Timestamp) string {
	var v time.Time
	if d != nil {
		v = time.Unix(int64(d.GetSeconds()), int64(d.GetNanos()))
	} else {
		v = time.Now()
	}
	return v.Format(time.RFC3339Nano)
}
